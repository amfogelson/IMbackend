from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from pathlib import Path
import xml.etree.ElementTree as ET
import re
from pydantic import BaseModel
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse, StreamingResponse
import io
import os

print("DEBUG: Backend main.py loaded with updated code!")

# Try to import cairosvg, but make it optional
try:
    import cairosvg
    CAIRO_AVAILABLE = True
except ImportError:
    CAIRO_AVAILABLE = False
    print("Warning: cairosvg not available. PNG export will be disabled.")

# --- Setup Directories ---
BASE_DIR = Path(__file__).parent.parent
ICON_DIR = BASE_DIR / "exported_svgs"
COLORFUL_ICON_DIR = BASE_DIR / "colorful_icons"  # New directory for colorful icons
FLAG_DIR = BASE_DIR / "flags"  # New directory for flags
ICON_DIR.mkdir(exist_ok=True)
COLORFUL_ICON_DIR.mkdir(exist_ok=True)
FLAG_DIR.mkdir(exist_ok=True)

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

app.mount("/static", StaticFiles(directory=ICON_DIR), name="static")
app.mount("/colorful-icons", StaticFiles(directory=COLORFUL_ICON_DIR), name="colorful-icons")
app.mount("/flags", StaticFiles(directory=FLAG_DIR), name="flags")
app.mount("/static-icons", StaticFiles(directory=ICON_DIR), name="static-icons")

# --- Pydantic Model ---
class UpdateColorRequest(BaseModel):
    icon_name: str
    group_id: str
    color: str
    type: str = "icon"  # "icon" or "flag"
    folder: str = "Root"  # folder name for icons

class ExportPngRequest(BaseModel):
    icon_name: str
    type: str = "icon"  # "icon" or "flag"
    folder: str = "Root"  # folder name for icons

class GreyscaleRequest(BaseModel):
    icon_name: str
    folder: str = "Root"  # folder name for colorful icons

class RevertRequest(BaseModel):
    icon_name: str
    folder: str = "Root"  # folder name for colorful icons

# --- Utility functions ---
def update_element_color(element, new_color):
    """Update the color of an SVG element"""
    print(f"DEBUG: update_element_color called on {element.tag} with color {new_color}")
    
    # Case 1: direct 'fill' attribute
    if 'fill' in element.attrib:
        old_fill = element.get('fill')
        element.set('fill', new_color)
        print(f"DEBUG: Updated fill attribute: {old_fill} -> {new_color}")

    # Case 2: inline 'style' attribute (style="fill:#xxxxxx;stroke:none")
    if 'style' in element.attrib:
        style = element.attrib['style']
        old_style = style
        # Replace fill color in style attribute
        style = re.sub(r'fill\s*:\s*#[0-9a-fA-F]{3,6}', f'fill:{new_color}', style)
        # If no fill color was found, add it
        if 'fill:' not in style:
            style += f';fill:{new_color}'
        element.set('style', style)
        print(f"DEBUG: Updated style attribute: {old_style} -> {style}")

    # Case 3: If no fill attribute or style, add fill attribute
    if 'fill' not in element.attrib and 'style' not in element.attrib:
        element.set('fill', new_color)
        print(f"DEBUG: Added fill attribute: {new_color}")

def convert_to_greyscale(element):
    """Convert an SVG element to greyscale by applying a filter"""
    # Add a greyscale filter to the element
    element.set('filter', 'url(#greyscale)')
    
    # If the element has a style attribute, add the filter there too
    if 'style' in element.attrib:
        style = element.attrib['style']
        if 'filter:' not in style:
            style += ';filter:url(#greyscale)'
            element.set('style', style)

def create_backup(filepath):
    """Create a backup of the original SVG file"""
    backup_path = filepath.with_suffix('.svg.backup')
    if not backup_path.exists():
        import shutil
        shutil.copy2(filepath, backup_path)
    return backup_path

def restore_from_backup(filepath):
    """Restore the original SVG from backup"""
    backup_path = filepath.with_suffix('.svg.backup')
    if backup_path.exists():
        import shutil
        shutil.copy2(backup_path, filepath)
        return True
    return False

@app.get("/")
async def root():
    return {"message": "Icon Manager Backend is running!", "cairo_available": CAIRO_AVAILABLE}

@app.get("/test")
async def test():
    return {"message": "Test endpoint working!", "debug": "Backend is responding"}

@app.get("/icons")
async def get_icons():
    # Get all folders and files in the ICON_DIR
    folders = {}
    
    # Get folders
    for folder_path in ICON_DIR.iterdir():
        if folder_path.is_dir():
            folder_name = folder_path.name
            # Get all SVG files in this folder
            svg_files = [f.stem for f in folder_path.glob("*.svg")]
            if svg_files:  # Only include folders that have SVG files
                folders[folder_name] = svg_files
    
    # Get SVG files in the root directory (not in folders)
    root_svgs = [f.stem for f in ICON_DIR.glob("*.svg")]
    if root_svgs:
        folders["Root"] = root_svgs
    
    # Sort folders by icon count (descending), then alphabetically for same count
    sorted_folders = dict(sorted(folders.items(), key=lambda x: (-len(x[1]), x[0])))
    
    return {"folders": sorted_folders}

@app.get("/icons/{folder_name}")
async def get_icons_from_folder(folder_name: str):
    if folder_name == "Root":
        # Get icons from root directory
        icons = [f.stem for f in ICON_DIR.glob("*.svg")]
    else:
        # Get icons from specific folder
        folder_path = ICON_DIR / folder_name
        if not folder_path.exists() or not folder_path.is_dir():
            return {"error": "Folder not found"}
        
        icons = [f.stem for f in folder_path.glob("*.svg")]
    
    # Sort icons alphabetically
    icons.sort()
    
    return {"icons": icons}

@app.get("/flags")
async def get_flags():
    flags = [f.name for f in FLAG_DIR.glob("*.svg")]
    return {"flags": flags}

@app.post("/export-png")
async def export_png(req: ExportPngRequest):
    if not CAIRO_AVAILABLE:
        return {"error": "PNG export not available. cairosvg is not installed."}
    
    if req.type == "icon":
        if req.folder == "Root":
            filepath = ICON_DIR / req.icon_name
        else:
            filepath = ICON_DIR / req.folder / req.icon_name
    elif req.type == "flag":
        filepath = FLAG_DIR / req.icon_name
    else:
        return {"error": "Invalid type"}
    
    if not filepath.exists():
        return {"error": "File not found"}

    try:
        # Read the SVG file
        with open(filepath, 'r', encoding='utf-8') as f:
            svg_content = f.read()
        
        # Convert SVG to PNG
        png_data = cairosvg.svg2png(bytestring=svg_content.encode('utf-8'))
        
        # Create filename for PNG
        png_filename = req.icon_name.replace('.svg', '.png')
        
        return StreamingResponse(
            io.BytesIO(png_data),
            media_type="image/png",
            headers={"Content-Disposition": f"attachment; filename={png_filename}"}
        )
    except Exception as e:
        return {"error": f"Failed to convert to PNG: {str(e)}"}

@app.get("/groups/{type}/{folder_name}/{icon_name}")
async def get_groups(type: str, folder_name: str, icon_name: str):
    if type == "icon":
        if folder_name == "Root":
            filepath = ICON_DIR / icon_name
        else:
            filepath = ICON_DIR / folder_name / icon_name
    elif type == "flag":
        filepath = FLAG_DIR / icon_name
    else:
        return {"groups": []}
    
    if not filepath.exists():
        return {"groups": []}

    ET.register_namespace('', "http://www.w3.org/2000/svg")
    tree = ET.parse(filepath)
    root = tree.getroot()
    namespaces = {'svg': 'http://www.w3.org/2000/svg'}

    groups = []
    for g in root.findall(".//svg:g", namespaces):
        group_id = g.get("id")
        if group_id:
            # Check if this group contains other groups with IDs (parent groups)
            has_child_groups_with_ids = False
            for child in g:
                if child.tag.endswith('g') and child.get("id"):
                    has_child_groups_with_ids = True
                    break
            
            # Only include groups that don't contain other groups with IDs
            # This excludes parent/container groups like "Layer_2"
            if not has_child_groups_with_ids:
                groups.append(group_id)
    
    return {"groups": groups}

@app.post("/update_color")
async def update_color(req: UpdateColorRequest):
    try:
        print(f"DEBUG: update_color called with {req}", flush=True)
        print("DEBUG: Starting function execution...", flush=True)
        
        if req.type == "icon" or req.type == "icons":
            print("DEBUG: Type is icon", flush=True)
            if req.folder == "Root":
                filepath = ICON_DIR / req.icon_name
            else:
                filepath = ICON_DIR / req.folder / req.icon_name
        elif req.type == "flag":
            print("DEBUG: Type is flag", flush=True)
            filepath = FLAG_DIR / req.icon_name
        else:
            print("DEBUG: Invalid type", flush=True)
            return {"error": "Invalid type"}
        
        print(f"DEBUG: Filepath: {filepath}", flush=True)
        
        if not filepath.exists():
            print(f"DEBUG: File not found: {filepath}", flush=True)
            return {"error": "File not found"}

        print(f"DEBUG: File exists, parsing SVG...", flush=True)
        ET.register_namespace('', "http://www.w3.org/2000/svg")
        tree = ET.parse(filepath)
        root = tree.getroot()
        namespaces = {"svg": "http://www.w3.org/2000/svg"}
        
        if req.group_id == "entire_flag":
            # For flags, update all elements in the SVG
            print(f"DEBUG: Updating entire flag with color {req.color}", flush=True)
            for element in root.iter():
                update_element_color(element, req.color)
        else:
            # For icons, update specific group
            print(f"DEBUG: Looking for group '{req.group_id}' in icon", flush=True)
            groups = []
            for g in root.findall(".//svg:g", namespaces):
                group_id = g.get("id")
                if group_id:
                    groups.append(group_id)

            print(f"DEBUG: Found groups: {groups}", flush=True)

            target_group = root.find(f".//svg:g[@id='{req.group_id}']", namespaces)
            if target_group is None:
                print(f"DEBUG: Group '{req.group_id}' not found!", flush=True)
                return {"error": "Group not found"}

            print(f"DEBUG: Found target group '{req.group_id}', updating with color {req.color}", flush=True)
            
            # Update all descendants inside the group
            updated_count = 0
            for element in target_group.iter():
                if element.tag.endswith(('path', 'rect', 'circle', 'ellipse', 'polygon', 'polyline', 'line')):
                    old_fill = element.get('fill', 'N/A')
                    old_style = element.get('style', 'N/A')
                    update_element_color(element, req.color)
                    new_fill = element.get('fill', 'N/A')
                    new_style = element.get('style', 'N/A')
                    if old_fill != new_fill or old_style != new_style:
                        updated_count += 1
                        print(f"DEBUG: Updated element {element.tag} - fill: {old_fill} -> {new_fill}, style: {old_style} -> {new_style}", flush=True)
            
            print(f"DEBUG: Updated {updated_count} elements in group '{req.group_id}'", flush=True)

        # Only remove <style> blocks directly under root
        for style_block in list(root.findall("svg:style", namespaces)):
            root.remove(style_block)

        # Write the file back
        print(f"DEBUG: Writing file back to {filepath}", flush=True)
        tree.write(filepath, encoding='utf-8', xml_declaration=True)
        print(f"DEBUG: File written successfully", flush=True)
        
        return {"status": "Color updated"}
    except Exception as e:
        print(f"DEBUG: Exception in update_color: {e}", flush=True)
        import traceback
        print(f"DEBUG: Traceback: {traceback.format_exc()}", flush=True)
        return {"error": f"Internal server error: {str(e)}"}

@app.get("/colorful-icons")
async def get_colorful_icons():
    # Get all folders and files in the COLORFUL_ICON_DIR
    folders = {}
    
    # Get folders
    for folder_path in COLORFUL_ICON_DIR.iterdir():
        if folder_path.is_dir():
            folder_name = folder_path.name
            # Get all SVG files in this folder
            svg_files = [f.stem for f in folder_path.glob("*.svg")]
            if svg_files:  # Only include folders that have SVG files
                folders[folder_name] = svg_files
    
    # Get SVG files in the root directory (not in folders)
    root_svgs = [f.stem for f in COLORFUL_ICON_DIR.glob("*.svg")]
    if root_svgs:
        folders["Root"] = root_svgs
    
    # Sort folders by icon count (descending), then alphabetically for same count
    sorted_folders = dict(sorted(folders.items(), key=lambda x: (-len(x[1]), x[0])))
    
    return {"folders": sorted_folders}

@app.post("/greyscale")
async def convert_to_greyscale_endpoint(req: GreyscaleRequest):
    if req.folder == "Root":
        filepath = COLORFUL_ICON_DIR / f"{req.icon_name}.svg"
    else:
        filepath = COLORFUL_ICON_DIR / req.folder / f"{req.icon_name}.svg"
    
    if not filepath.exists():
        return {"error": "File not found"}

    try:
        # Create backup of original file before converting
        create_backup(filepath)
        
        ET.register_namespace('', "http://www.w3.org/2000/svg")
        tree = ET.parse(filepath)
        root = tree.getroot()
        
        # Add greyscale filter definition if it doesn't exist
        defs = root.find(".//{http://www.w3.org/2000/svg}defs")
        if defs is None:
            defs = ET.SubElement(root, "defs")
        
        # Check if greyscale filter already exists
        existing_filter = defs.find(".//{http://www.w3.org/2000/svg}filter[@id='greyscale']")
        if existing_filter is None:
            # Create greyscale filter
            filter_elem = ET.SubElement(defs, "filter", id="greyscale")
            fe_color_matrix = ET.SubElement(filter_elem, "feColorMatrix", 
                                          type="matrix", 
                                          values="0.299 0.587 0.114 0 0 0.299 0.587 0.114 0 0 0.299 0.587 0.114 0 0 0 0 0 1 0")
        
        # Apply greyscale filter to all path and rect elements
        for element in root.findall(".//{http://www.w3.org/2000/svg}path") + root.findall(".//{http://www.w3.org/2000/svg}rect"):
            convert_to_greyscale(element)
        
        # Apply greyscale filter to all other elements that can have colors
        for element in root.findall(".//{http://www.w3.org/2000/svg}circle") + root.findall(".//{http://www.w3.org/2000/svg}ellipse") + root.findall(".//{http://www.w3.org/2000/svg}polygon") + root.findall(".//{http://www.w3.org/2000/svg}polyline") + root.findall(".//{http://www.w3.org/2000/svg}line"):
            convert_to_greyscale(element)
        
        # Save the modified SVG
        tree.write(filepath, encoding='utf-8', xml_declaration=True)
        
        return {"status": "Converted to greyscale"}
    except Exception as e:
        return {"error": f"Failed to convert to greyscale: {str(e)}"}

@app.post("/revert")
async def revert_to_color_endpoint(req: RevertRequest):
    if req.folder == "Root":
        filepath = COLORFUL_ICON_DIR / f"{req.icon_name}.svg"
    else:
        filepath = COLORFUL_ICON_DIR / req.folder / f"{req.icon_name}.svg"
    
    if not filepath.exists():
        return {"error": "File not found"}

    try:
        # Restore from backup
        if restore_from_backup(filepath):
            return {"status": "Reverted to original colors"}
        else:
            return {"error": "No backup found to revert from"}
    except Exception as e:
        return {"error": f"Failed to revert to original colors: {str(e)}"}

@app.get("/check-greyscale/{folder_name}/{icon_name}")
async def check_greyscale(folder_name: str, icon_name: str):
    if folder_name == "Root":
        filepath = COLORFUL_ICON_DIR / f"{icon_name}.svg"
    else:
        filepath = COLORFUL_ICON_DIR / folder_name / f"{icon_name}.svg"
    
    if not filepath.exists():
        return {"error": "File not found"}

    try:
        ET.register_namespace('', "http://www.w3.org/2000/svg")
        tree = ET.parse(filepath)
        root = tree.getroot()
        
        # Check if greyscale filter exists in the SVG
        defs = root.find(".//{http://www.w3.org/2000/svg}defs")
        if defs is not None:
            greyscale_filter = defs.find(".//{http://www.w3.org/2000/svg}filter[@id='greyscale']")
            if greyscale_filter is not None:
                return {"is_greyscale": True}
        
        return {"is_greyscale": False}
    except Exception as e:
        return {"error": f"Failed to check greyscale status: {str(e)}"}

def reset_group_color_in_svg(file_path, group_id, target_color):
    """Reset a group (by id) in an SVG file to a target color and remove individual fill attributes from its children."""
    try:
        tree = ET.parse(file_path)
        root = tree.getroot()
        namespace = {'ns0': 'http://www.w3.org/2000/svg'}
        groups = root.findall(f'.//ns0:g[@id="{group_id}"]', namespace)
        if not groups:
            return False
        modified = False
        for group in groups:
            group.set('fill', target_color)
            modified = True
            for child in group.iter():
                if child != group and 'fill' in child.attrib:
                    del child.attrib['fill']
        if modified:
            tree.write(file_path, encoding='utf-8', xml_declaration=True)
            return True
        return False
    except Exception as e:
        print(f"Error processing {file_path}: {e}")
        return False

def main():
    exported_svgs_path = Path("IMbackend/exported_svgs")
    if not exported_svgs_path.exists():
        print(f"Directory {exported_svgs_path} not found!")
        return
    total_files = 0
    updated_files = 0
    for root, dirs, files in os.walk(exported_svgs_path):
        for file in files:
            if file.endswith('.svg'):
                file_path = Path(root) / file
                total_files += 1
                updated = False
                # Reset Color group to blue
                if reset_group_color_in_svg(file_path, 'Color', '#00ABF6'):
                    updated = True
                # Reset Grey group to #282828
                if reset_group_color_in_svg(file_path, 'Grey', '#282828'):
                    updated = True
                if updated:
                    updated_files += 1
                    print(f"Updated: {file_path}")
    print(f"\nSummary:")
    print(f"Total SVG files processed: {total_files}")
    print(f"Files updated: {updated_files}")
    print(f"Files unchanged: {total_files - updated_files}")

if __name__ == "__main__":
    import uvicorn
    import os
    
    # Get port from environment variable (Railway sets this)
    port = int(os.environ.get("PORT", 8000))
    
    print(f"Starting server on port {port}")
    print(f"Environment: {os.environ.get('RAILWAY_ENVIRONMENT', 'development')}")
    
    try:
        uvicorn.run(app, host="0.0.0.0", port=port, log_level="info")
    except Exception as e:
        print(f"Failed to start server: {e}")
        raise

